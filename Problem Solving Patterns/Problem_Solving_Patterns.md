# PROBLEM SOLVING PATTERNS

1. Frequency Counter
2. Multiple Pointers
3. Sliding Windows
4. Divide and Conquer
5. Dynamic Programming
6. Greedy Algorithms
7. Backtracking

---

## Detailed Explanation of the patterns

### 1. Frequency Counter

- This pattern uses objects or sets to collect values/frequencies of values
- This can often avoid the need for nested loops or O(n^2) operations with arrays / strings

[Square of first in second. Example](/Problem%20Solving%20Patterns/compareSquaredArrays.js)
[Anagram. Example](/Problem%20Solving%20Patterns/anagrams.js)

### 2. Multiple Pointers

- Creating pointers or values that correspond to an index or position and moves towards the beginning, end or middle based on a certain condition
- Very efficient for solving problems with minimal space complexity as well as nested loops

[Sum Zero. Example](/Problem%20Solving%20Patterns/sumZero.js)
[Count unique values. Example](/Problem%20Solving%20Patterns/countUniqueValues.js)

### 3. Sliding Window

- This pattern involves creating a window which can either be an array or number from one position to another
- Depending on a certain condition the window either increases or closes (and new window is created)
- Very useful for keeping track of a subset of data in an array/string etc.

[maxSumArray. Example](/Problem%20Solving%20Patterns/maxSum.js)

### 4. Divide and Conquer

- This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data
- This pattern can tremendously decrease time complexity

[basicBinarySearch. Example](/Problem%20Solving%20Patterns/maxSum.js)

---
